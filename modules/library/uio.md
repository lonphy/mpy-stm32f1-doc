---
layout: post
title:  "MicroPython uio - 输入/出流"
date:   2019-08-18 0:0:0 +0000
category: library
---

此模块包含附加类型的 _流_ (类文件)对象和帮助函数

层次结构
====================

> 与 _CPython_ 差异: 如本页所述, 流基类 的层次结构在 _MicroPython_ 进行了简化.

(抽象)流基类作为所有具体类行为的基础，与 _CPython_ 差异不大.  
在 _MicroPython_ 中, 为了更高效率及减少资源占用, 它们在一定程度上进行了简化和隐式处理


_CPython_ 中一个重要的分支是 __缓冲流__ 和 __无缓冲流__.

在 _MicroPython_ 里，所有流一般都是 _无缓冲_ 的, 因为所有 _现代操作系统_, 甚至 _RTOS_ 及 _文件系统驱动_ 都在底层进行了缓冲.  
添加额外一层缓冲会产生反效果(_bufferbloat_ 问题), 而且会占用宝贵的内存  
<small>注意: 在某些情况下缓冲仍然是有用的，因此会在稍后引入可选的 _缓冲_ 支持</small>


但在 _CPython_ 中, 另一个重要的分支与 _缓冲_ 有关——它可能会导致流 _短读写_ ,  

<small>_短读_ 是指用户从流中请求10字节，但实际得到的字节数不够，写操作与此类似</small>

在 _CPython_ 中，__无缓冲流__ 易受 _短操作_ 影响, 而 _缓冲流_ 则不受影响.   
无 _短读/写_ 是很重要的特性, 因为它允许开发简洁、高效的程序，这是 _MicroPython_ 非常需要的.  
因此，虽然 _MicroPython_ 不支持 __缓冲流__，但它仍然提供了 _无短操作_ 流.  
是否支持短操作取决于每个特定类的需要，但因上述原因，开发人员强烈建议支持无短操作行为.  
例如, _MicroPython_ 套接字需要避免避免 _短读/写_.
实际上，目前在核心中还没有支持短操作的流类的例子，一个是平台特定类，这取决于硬件特性.

在非阻塞流的情况下，_非短操作_ 行为变得很棘手，阻塞与非阻塞行为是另一种 _CPython_ 分类, _MicroPython_ 完全支持  

_非阻塞流_ 不等待数据到达或被写入(它们读写任何可能的数据), 或者缺乏信号数据(或数据写能力).

显然，这与 "非短操作" 策略冲突, 实际上, 在 _CPython_ 中，在某些地方非阻塞缓冲(以及这种非短操作)流是复杂的，禁止这样的组合, 在一些些地方是未定义的, 或者只是没有文档说明,
在某些情况下，它会引发啰嗦的异常.

在 _MicroPython_ 中问题要简单得多: _非阻塞流_ 对于高效的异步操作非常重要, 因此这种特性在“非短操作”中很流行.
因此，尽管 _阻塞流_ 将尽可能地避免 _短读/写_ ( _短读_ 的惟一情况是`EOF`，或者出现错误(但不会返回短数据，而是引发异常)), _非阻塞流_ 可能会产生 _短数据_, 以避免阻塞操作.

最后一个分支是 __二进制流__ 和 __文本流__. _MicroPython_ 当然支持这些，但在 _CPython_ 中 __文本流__ 本身是缓冲的，而在 _MicroPython__ 中则不是。(实际上，这是我们引入缓冲支持的情况之一)  
<small>注意, 为了提高效率, _MicroPython_ 不提供 __层次结构__ 对应的抽象基类, 并且不可能在纯Python中实现流类或子类</small>



函数
=========

###### `uio.open(name, mode='r', **kwargs)`{:class="func"}


打开一个文件. 内置 `open()` 函数 是本函数的别名. 所有的平台都支持 `mode`参数.


类
=======

##### `uio.FileIO(...)`{:class="class"}

以二进制模式打开文件的类型, 例如使用`open(name, 'rb')`, 不应直接实例化该类

##### `uio.TextIOWrapper(...)`{:class="class"}
以文本模式打开文件的类型, 例如使用`open(name, 'rt')`, 不应直接实例化该类

##### `uio.StringIO([string])`{:class="class"}
##### `uio.BytesIO([string])`{:class="class"}

读写  _内存类文件_ 对象. `StringIO` 用于文本模式读写(类似用 _t_ 模式打开的普通文件).
`BytesIO` 用于二进制模式读写(类似用 _b_ 模式打开的普通文件).
_类文件_ 对象内容初始化可用 `string` 参数指定(`StringIO` 用字符串, `BytesIO` 用 `bytes` ).

所有通用文件方法(如 `read()`, `write()`, `seek()`, `flush()`, `close()`)都可用于 _类文件_ 对象, 额外还有个方法可用:

###### `getvalue()`{:class="method"}
获取底层缓冲当前数据内容.

##### `uio.StringIO(alloc_size)`{:class="class"}
##### `uio.BytesIO(alloc_size)`{:class="class"}

创建一个空 `StringIO`/`BytesIO` 对象, 预分配 `alloc_size` 字节大小的内存,
这意味着写入这些字节不会导致缓冲区的重新分配，因此不会出现内存不足的情况或导致内存碎片.

这些构造方法是 _MicroPython_ 特有扩展, 建议仅在特殊情况下和系统级库中使用，而不用于最终用户应用程序。

<br><br>