---
layout: post
title:  "MicroPython uio - 输入/出流"
date:   2019-08-18 0:0:0 +0000
category: library
---

此模块包含附加类型的 *流* (类文件)对象和帮助函数

层次结构
====================

> 与 *CPython* 差异: 如本页所述, 流基类 的层次结构在 *MicroPython* 进行了简化.

(抽象)流基类作为所有具体类行为的基础，与 *CPython* 差异不大.  
在 *MicroPython* 中, 为了更高效率及减少资源占用, 它们在一定程度上进行了简化和隐式处理


*CPython* 中一个重要的分支是 **缓冲流** 和 **无缓冲流**.

在 *MicroPython* 里，所有流一般都是 *无缓冲* 的, 因为所有 *现代操作系统*, 甚至 *RTOS* 及 *文件系统驱动* 都在底层进行了缓冲.  
添加额外一层缓冲会产生反效果(*bufferbloat* 问题), 而且会占用宝贵的内存  
<small>注意: 在某些情况下缓冲仍然是有用的，因此会在稍后引入可选的 *缓冲* 支持</small>


但在 *CPython* 中, 另一个重要的分支与 *缓冲* 有关——它可能会导致流 *短读写* ,  

<small>*短读* 是指用户从流中请求10字节，但实际得到的字节数不够，写操作与此类似</small>

在 *CPython* 中，**无缓冲流** 易受 *短操作* 影响, 而 *缓冲流* 则不受影响.   
无 *短读/写* 是很重要的特性, 因为它允许开发简洁、高效的程序，这是 *MicroPython* 非常需要的.  
因此，虽然 *MicroPython* 不支持 **缓冲流**，但它仍然提供了 *无短操作* 流.  
是否支持短操作取决于每个特定类的需要，但因上述原因，开发人员强烈建议支持无短操作行为.  
例如, *MicroPython* 套接字需要避免避免 *短读/写*.
实际上，目前在核心中还没有支持短操作的流类的例子，一个是平台特定类，这取决于硬件特性.

在非阻塞流的情况下，*非短操作* 行为变得很棘手，阻塞与非阻塞行为是另一种 *CPython* 分类, *MicroPython* 完全支持  

*非阻塞流* 不等待数据到达或被写入(它们读写任何可能的数据), 或者缺乏信号数据(或数据写能力).

显然，这与 "非短操作" 策略冲突, 实际上, 在 *CPython* 中，在某些地方非阻塞缓冲(以及这种非短操作)流是复杂的，禁止这样的组合, 在一些些地方是未定义的, 或者只是没有文档说明,
在某些情况下，它会引发啰嗦的异常.

在 *MicroPython* 中问题要简单得多: *非阻塞流* 对于高效的异步操作非常重要, 因此这种特性在“非短操作”中很流行.
因此，尽管 *阻塞流* 将尽可能地避免 *短读/写* ( *短读* 的惟一情况是`EOF`，或者出现错误(但不会返回短数据，而是引发异常)), *非阻塞流* 可能会产生 *短数据*, 以避免阻塞操作.

最后一个分支是 **二进制流** 和 **文本流**. *MicroPython* 当然支持这些，但在 *CPython* 中 **文本流** 本身是缓冲的，而在 *MicroPython*_ 中则不是。(实际上，这是我们引入缓冲支持的情况之一)  
<small>注意, 为了提高效率, *MicroPython* 不提供 **层次结构** 对应的抽象基类, 并且不可能在纯Python中实现流类或子类</small>



函数
=========

###### `uio.open(name, mode='r', **kwargs)`{:class="func"}


打开一个文件. 内置 `open()` 函数 是本函数的别名. 所有的平台都支持 `mode`参数.


类
=======

##### `uio.FileIO(...)`{:class="class"}

以二进制模式打开文件的类型, 例如使用`open(name, 'rb')`, 不应直接实例化该类

##### `uio.TextIOWrapper(...)`{:class="class"}
以文本模式打开文件的类型, 例如使用`open(name, 'rt')`, 不应直接实例化该类

##### `uio.StringIO([string])`{:class="class"}
##### `uio.BytesIO([string])`{:class="class"}

读写  *内存类文件* 对象. `StringIO` 用于文本模式读写(类似用 *t* 模式打开的普通文件).
`BytesIO` 用于二进制模式读写(类似用 *b* 模式打开的普通文件).
*类文件* 对象内容初始化可用 `string` 参数指定(`StringIO` 用字符串, `BytesIO` 用 `bytes` ).

所有通用文件方法(如 `read()`, `write()`, `seek()`, `flush()`, `close()`)都可用于 *类文件* 对象, 额外还有个方法可用:

###### `getvalue()`{:class="method"}
获取底层缓冲当前数据内容.

##### `uio.StringIO(alloc_size)`{:class="class"}
##### `uio.BytesIO(alloc_size)`{:class="class"}

创建一个空 `StringIO`/`BytesIO` 对象, 预分配 `alloc_size` 字节大小的内存,
这意味着写入这些字节不会导致缓冲区的重新分配，因此不会出现内存不足的情况或导致内存碎片.

这些构造方法是 *MicroPython* 特有扩展, 建议仅在特殊情况下和系统级库中使用，而不用于最终用户应用程序。

<br><br>